<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="google-site-verification" content="0_tpf6zJsJqBBDzICQsb2Cx-cfNrUiyIUWte196o0IU"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个记录生活日常的网站"><title>C#学习笔记（二）-Timer | 程小猿</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C#学习笔记（二）-Timer</h1><a id="logo" href="/.">程小猿</a><p class="description">生活不只有眼前的苟且，还有代码和bug</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C#学习笔记（二）-Timer</h1><div class="post-meta">Dec 6, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>在C#里现在有3个Timer类：</p>
<ul>
<li><strong>System.Windows.Forms.Timer</strong></li>
<li><strong>System.Threading.Timer</strong></li>
<li><strong>System.Timers.Timer</strong></li>
</ul>
<p>这三个Timer我想大家对<strong>System.Windows.Forms.Timer</strong>已经很熟悉了，唯一我要说的就是这个Timer在激发Timer.Tick事件的时候，事件的处理函数是在程序主线程上执行的，所以在WinForm上面用这个Timer很方便，因为在From上的所有控件都是在程序主线程上创建的，那么在Tick的处理函数中可以对Form上的所有控件进行操作，不会造成WinForm控件的线程安全问题。</p>
<h3 id="1-Timer运行的核心都是System-Threading-ThreadPool"><a href="#1-Timer运行的核心都是System-Threading-ThreadPool" class="headerlink" title="1.Timer运行的核心都是System.Threading.ThreadPool"></a><strong>1.Timer运行的核心都是System.Threading.ThreadPool</strong></h3><p>在这里要提到ThreadPool（线程池）是因为，System.Threading.Timer 和System.Timers.Timer运行的核心都是线程池，Timer每到间隔时间后就会激发响应事件，因此要申请线程来执行对应的响应函数，Timer将获取线程的工作都交给了线程池来管理，每到一定的时间后它就去告诉线程池：“我现在激发了个事件要运行对应的响应函数，麻烦你给我向操作系统要个线程，申请交给你了，线程分配下来了你就运行我给你的响应函数，没分配下来先让响应函数在这儿排队（操作系统线程等待队列）”，消息已经传递给线程池了，Timer也就不管了，因为它还有其他的事要做（每隔一段时间它又要激发事件），至于提交的请求什么时候能够得到满足，要看线程池当前的状态：</p>
<ol>
<li><p>如果线程池现在有线程可用，那么申请马上就可以得到满足，有线程可用又可以分为两种情况： </p>
<ul>
<li><p>线程池现在有空闲线程，现在马上就可以用</p>
</li>
<li><p>线程池本来现在没有线程了，但是刚好申请到达的时候，有线程运行完毕释放了，那么申请就可以用别人释放的线程。</p>
<p><strong>这两种情况情况就如同你去游乐园玩赛车，如果游乐园有10辆车，现在有3个人在玩，那么还剩7辆车，你去了当然可以选一辆开。另外还有一种情况就是你到达游乐园前10辆车都在开，但是你运气很好，刚到游乐园就有人不玩了，正好你坐上去就可以接着开。</strong></p>
</li>
</ul>
</li>
<li><p>如果现在线程池现在没有线程可用，也分为两种情况：</p>
<ul>
<li>线程池现有线程数没有达到设置的<em>最大工作线程数</em>，那么隔半秒钟.net framework就会向操作系统申请一个新的线程（为避免向线程分配不必要的堆栈空间，线程池按照一定的时间间隔创建新的空闲线程。该时间间隔目前为半秒，但它在 .NET Framework 的以后版本中可能会更改）。</li>
<li>线程池现有工作线程数达到了设置的<em>最大工作线程数</em>，那么申请只有在等待队列一直等下去，直到有线程执行完任务后被释放。</li>
</ul>
<p>那么上面提到了线程池有<em>最大工作线程数</em>，其实还有<em>最小空闲线程数</em>，那么这两个关键字是什么意思呢：</p>
</li>
<li><p>最大工作线程数:实际上就是指的线程池能够向操作系统申请的最大线程数，这个值在.net framework中有默认值，这个默认值是根据你计算机的配置来的，当人你可以用ThreadPool.GetMaxThreads返回线程池当前最大工作线程数，你也可以同ThreadPool.SetMaxThreads设置线程池当前最大工作线程数。</p>
</li>
<li>最小空闲线程数：是指在程序开始后，线程池就默认向操作系统要最小空闲线程数个线程，另外这也是线程池维护的空闲线程数（如果线程池最小空闲线程数为3，当前因为一些线程执行完任务被释放，线程池现在实际上有10个空闲线程，那么线程池会让操作系统释放多余的7个线程，而只维持3个空闲线程供程序使用），因为上面说了，在执行程序的时候在要线程池申请线程有半秒的延迟时间，这也会影响程序的性能，所以把握好这个值很重要，用样你可以用ThreadPool.GetMinThreads返回线程池当前最小空闲线程数，你也可以同ThreadPool.SetMinThreads设置线程池当前最小空闲线程数。</li>
</ol>
<p>下面是的例子，这个例子让线程池申请800个线程，其中设置最大工作线程数为500，800个线程任务每个都要执行100000000毫秒目的是让线程不会释放，并且让用户选择，是否预先申请500个空闲线程免受那半秒钟的延迟时间，其结果可想而知当线程申请到500的时候，线程池达到了最大工作线程数，剩余的300个申请进入漫长的等待时间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/***************************************************</span><br><span class="line"> * 项目:测试线程池</span><br><span class="line"> * 描述:验证线程池的最大工作线程数和最小空闲线程数</span><br><span class="line"> * 作者:@PowerCoder</span><br><span class="line"> * 日期:2010-2-22</span><br><span class="line">***************************************************/</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static int i=1;</span><br><span class="line">        static int MaxThreadCount = 800;</span><br><span class="line"></span><br><span class="line">        static void OutPut(object obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(&quot;\r申请了:&#123;0&#125;个工作线程&quot;,i);</span><br><span class="line">            i++;</span><br><span class="line">            Thread.Sleep(100000000);//设置一个很大的等待时间，让每个申请的线程都一直执行</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int j;</span><br><span class="line">            </span><br><span class="line">            Console.Write(&quot;是否先申请500个空闲线程以保证前500个线程在线程池中开始就有线程用(Y/N)?&quot;);//如果这里选择N，那么前两个任务是用的线程池默认空闲线程（可以用ThreadPool.GetMinThreads得到系统默认最小空闲线程数为2）申请立即得到满足，然而由于每个线程等待时间非常大都不会释放当前自己持有的线程，因此线程池中已无空闲线程所用，后面的任务需要在线程池中申请新的线程，那么新申请的每个线程在线程池中都要隔半秒左右的时间才能得到申请（原因请见下面的注释）</span><br><span class="line">            string key = Console.ReadLine();</span><br><span class="line">            if(key.ToLower()==&quot;y&quot;)</span><br><span class="line">                ThreadPool.SetMinThreads(500, 10);//设置最大空闲线程为500，就好像我告诉系统给我预先准备500个线程我来了就直接用，因为这样就不用现去申请了，在线程池中每申请一个新的线程.NET Framework 会安排一个间隔时间，目前是半秒，以后的版本MS有可能会改</span><br><span class="line">            </span><br><span class="line">            int a, b;</span><br><span class="line">            ThreadPool.GetMaxThreads(out a,out b);</span><br><span class="line">            Console.WriteLine(&quot;线程池默认最大工作线程数：&quot; + a.ToString() + &quot;     默认最大异步 I/O 线程数：&quot; + b.ToString());</span><br><span class="line">            Console.WriteLine(&quot;需要向系统申请&quot; + MaxThreadCount.ToString()+&quot;个工作线程&quot;);</span><br><span class="line"></span><br><span class="line">            for (j = 0; j &lt;= MaxThreadCount-1; j++)//由于ThreadPool.GetMaxThreads返回的默认最大工作线程数为500（这个值要根据你计算机的配置来决定），那么向线程池申请大于500个线程的时候，500之后的线程会进入线程池的等待队列，等待前面500个线程某个线程执行完后来唤醒等待队列的某个线程 </span><br><span class="line">            &#123;</span><br><span class="line">                ThreadPool.QueueUserWorkItem(new WaitCallback(OutPut));</span><br><span class="line">                Thread.Sleep(10);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谈完了线程池，就可以开始讨论Timer，这里我们先从System.Threading.Timer开始，System.Threading.Timer的作用就是每到间隔时间后激发响应事件并执行相应函数，执行响应函数要向线程池申请线程，当然申请中会遇到一些情况在上面我们已经说了。值得注意的一点就是System.Threading.Timer在创建对象后立即开始执行，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Threading.Timer timer = new System.Threading.Timer(Excute, null, 0, 10);</span><br></pre></td></tr></table></figure>
<p>这句执行完后每隔10毫秒就执行Excute函数不需要启动什么的。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://ionestu.top/2017/12/06/C-学习笔记（二）-Timer/" data-id="ckrp7pzkm00022kw42cwy8iug" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLklEQVR42u3aS27DMAwFwNz/0i5QdFGgtfNIOkUjjVZB4hgaLQjx83jE6/hcPz+fPfl9nb3h53vOvr9tYWBgvC3juFwJ42yLydavGcneMDAw9mEkQbYaRq8D6/W/8r1hYGBg9EjX30yCOwYGBkYeFvOMshpYMTAwMCZJbJ6gHsX1p7k4BgbGGzImjYFXf/6j/gYGBsY/ZvTCYp7W5g3O3n6+3oCBgbE0Iy+TVQtt1TS42mx4JHktBgbGEow88PUaBr3WQrUJioGBsQPjde3M/AgmGSsGBsbajHwkolqmz696+R0PAwNjT8a9l7nqr/kzTw4IAwNjaUZ1i5NLZK//WCgLYmBgbMaobn0yeHr9r0IpEAMDYxtGLyD2Et3qoFg0bIGBgbEcI78OzlPNamDNxz4wMDB2Y1yX6XNwXlDLj6M8FoaBgbEEozqMlV/mqkNmNwxnYGBgLMqYv7o6ztUrsT05XAwMjKUZ0c9xUlq9JlbD8eiei4GB8eaMXvCdFOMmhTYMDIzdGNVCf3UYIt9ockxRFo6BgbEoIw+4+XH0xiyahT8MDIylGdUUNI9vo8JZMehjYGCszTiK695S/qQtcToWhoGBsRxj3oDMA3e1GVBNdDEwMNZmzIPsMV6TqyoGBsY+jHuT1fm1shz0MTAwMIrXwd6gRjK68aTohoGBgdEKmnlbNP/+lycxMDA2YORhLh8Oy696k8wUAwNjB8YkgayW+Hvtz96wGgYGxhKMDx+FYL7SQXV+AAAAAElFTkSuQmCC" class="article-share-link">分享</a><div class="tags"><a href="/tags/C-线程/">C#线程</a><a href="/tags/Timer/">Timer</a></div><div class="post-nav"><a href="/2021/07/30/menuconfig学习笔记/" class="pre">menuconfig学习笔记</a><a href="/2017/11/29/C-学习笔记（一）/" class="next">C#学习笔记（一）</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMTkyNS84NDg5"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://ionestu.top"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/NET/" style="font-size: 15px;">.NET</a> <a href="/tags/C-线程/" style="font-size: 15px;">C#线程</a> <a href="/tags/Timer/" style="font-size: 15px;">Timer</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Springframework/" style="font-size: 15px;">Springframework</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/menuconfig可视化/" style="font-size: 15px;">menuconfig可视化</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/30/menuconfig学习笔记/">menuconfig学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/C-学习笔记（二）-Timer/">C#学习笔记（二）-Timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/29/C-学习笔记（一）/">C#学习笔记（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/20/如何使用Windows10自带的linux系统/">如何使用Windows10自带的linux系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/17/SpringMVC-Spring-Mybatis整合记录/">SpringMVC Spring Mybatis整合记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/17/算法初探之二分查找/">算法初探之二分查找</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/JiZhiqi" title="欢迎交换友链" target="_blank">欢迎交换友链</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">下雨.</a> 由<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo 强力驱动.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="#"> Maupassant.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" color="150,150,150" opacity="0.8" zindex="-1" count="160" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>